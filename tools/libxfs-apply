#!/bin/bash

# 2 args:
#	libxfs-apply <repo> <commit ID or patchfile>

usage()
{
	echo $*
	echo
	echo "Usage:"
	echo "	libxfs-apply --source <repodir> --commit <commit_id>"
	echo "	libxfs-apply --patch <patchfile>"
	echo
	echo "libxfs-apply should be run in the destination git repository."
	exit
}

cleanup()
{
	rm -f $PATCH $LIBXFS_FILES $NEWPATCH
}

fail()
{
	echo "Fail:"
	echo $*
	cleanup
	exit
}

# We should see repository contents we recognise, both at the source and
# destination. Kernel repositorys will have fs/xfs/libxfs, and xfsprogs
# repositories will have libxcmd.
check_repo()
{
	if [ ! -d "fs/xfs/libxfs" -a ! -d "libxcmd" ]; then
		usage "$1 repository contents not recognised!"
	fi
}

REPO=
PATCH=
COMMIT_ID=
GUILT=0

while [ $# -gt 0 ]; do
	case "$1" in
	--source)	REPO=$2 ; shift ;;
	--patch)	PATCH=$2; shift ;;
	--commit)	COMMIT_ID=$2 ; shift ;;
	*)		usage ;;
	esac
	shift
done

if [ -n "$PATCH" ]; then
	if [ -n "$REPO" -o -n "$COMMIT_ID" ]; then
		usage "Need to specify either patch or source epo/commit"
	fi
elif [ -z "$REPO" -o -z "$COMMIT_ID" ]; then
	usage "Need to specify both source repo and commit id"
fi

check_repo Destination

LIBXFS_FILES=`mktemp`
NEWPATCH=`mktemp`

# switch to source repo and pull the commit into the patch file
if [ -n "$COMMIT_ID" ]; then
	pushd $REPO > /dev/null
	check_repo Source
	PATCH=`mktemp`
	git show $2 > $PATCH || usage "Bad source commit ID!"
	popd > /dev/null
fi

# Are we using guilt? This works even if no patch is applied.
guilt top &> /dev/null
if [ $? -eq 0 ]; then
	GUILT=1
fi

# Filter the patch into the right format & files for the other tree

if   [ -d "fs/xfs/libxfs" ]; then	# We are applying a progs patch to the kernel tree
	lsdiff $PATCH | grep -q "a/libxfs/"
	if [ $? -ne 0 ]; then
		fail "Doesn't look like an xfsprogs patch with libxfs changes"
	fi

	# The files we will try to apply to
	ls -1 fs/xfs/libxfs/*.[ch] | sed -e "s%.*/\(.*\)%*\1%" > $LIBXFS_FILES

	# Create the new patch
	filterdiff \
		-I $LIBXFS_FILES \
		--strip=1 \
		--addoldprefix=a/fs/xfs/ \
		--addnewprefix=b/fs/xfs/ \
		$PATCH > $NEWPATCH 

elif [ -d "libxfs" -a -d "libxlog" ]; then	# We are applying a kernel patch to the xfsprogs tree
	lsdiff $PATCH | grep -q "a/fs/xfs/libxfs/"
	if [ $? -ne 0 ]; then
		fail "Doesn't look like a kernel patch with libxfs changes"
	fi

	# The files we will try to apply to
	ls -1 libxfs/*.[ch] | sed -e "s%.*/\(.*\)%*\1%" > $LIBXFS_FILES

	# Create the new patch
	filterdiff \
		-I $LIBXFS_FILES \
		--strip=3 \
		--addoldprefix=a/ \
		--addnewprefix=b/ \
		$PATCH > $NEWPATCH 
fi

echo "Filtered patch for $REPO contains:"
lsdiff $NEWPATCH


# Ok, now apply with guilt or patch; either may fail and require a force
# and/or a manual reject fixup
if [ $GUILT -eq 1 ]; then
	echo "$REPO looks like a guilt directory."
	PATCHES=`guilt applied | wc -l`
	if [ $PATCHES -gt 0 ]; then
		echo -n "Top patch is: "
		guilt top
	fi
	read -r -p "Create new Guilt patch? (Enter patch name or return to skip) " response
	[ -z "$response" ] && guilt refresh; guilt import -P $response $NEWPATCH; guilt push
else
	echo "Applying with patch utility:"
	patch -p1 < $NEWPATCH
fi

echo "Patch was applied in $REPO; check for rejects, guilt push -f, etc"

cleanup
